<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2D Predator-Prey Model: Grid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2D Predator-Prey Model
   </div>
   <div id="projectbrief">Simulation of a 2D predator-prey model for pumas and hares on a landscape that contains water and land</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grid Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Models a 2D landscape of cells.  
 <a href="class_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_grid_8hpp_source.html">Grid.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ac9ff4f63552b4c61ff90fcb35ad66c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a4ac9ff4f63552b4c61ff90fcb35ad66c">Grid</a> ()</td></tr>
<tr class="memdesc:a4ac9ff4f63552b4c61ff90fcb35ad66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a4ac9ff4f63552b4c61ff90fcb35ad66c">More...</a><br /></td></tr>
<tr class="separator:a4ac9ff4f63552b4c61ff90fcb35ad66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f5607521a89e7a2fb99cbfa5f2b44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#ab64f5607521a89e7a2fb99cbfa5f2b44">Grid</a> (int columns, int rows, int **const data)</td></tr>
<tr class="memdesc:ab64f5607521a89e7a2fb99cbfa5f2b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from some input array representing the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a>.  <a href="#ab64f5607521a89e7a2fb99cbfa5f2b44">More...</a><br /></td></tr>
<tr class="separator:ab64f5607521a89e7a2fb99cbfa5f2b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5432331273bc420c252ea09631965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a2be5432331273bc420c252ea09631965">Grid</a> (const <a class="el" href="class_grid.html">Grid</a> &amp;sourceGrid)</td></tr>
<tr class="memdesc:a2be5432331273bc420c252ea09631965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with deep copying.  <a href="#a2be5432331273bc420c252ea09631965">More...</a><br /></td></tr>
<tr class="separator:a2be5432331273bc420c252ea09631965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828d0bf34f6c97ed93adc84d4ce6c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a3828d0bf34f6c97ed93adc84d4ce6c4b">Grid</a> (<a class="el" href="class_grid.html">Grid</a> &amp;&amp;sourceGrid)</td></tr>
<tr class="memdesc:a3828d0bf34f6c97ed93adc84d4ce6c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with move semantics.  <a href="#a3828d0bf34f6c97ed93adc84d4ce6c4b">More...</a><br /></td></tr>
<tr class="separator:a3828d0bf34f6c97ed93adc84d4ce6c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661d0a7f998caaaf8627d7a67072116"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a3661d0a7f998caaaf8627d7a67072116">~Grid</a> ()</td></tr>
<tr class="memdesc:a3661d0a7f998caaaf8627d7a67072116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory held by m_cellArray.  <a href="#a3661d0a7f998caaaf8627d7a67072116">More...</a><br /></td></tr>
<tr class="separator:a3661d0a7f998caaaf8627d7a67072116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7b118be13f65bf2e3a72881d8a06df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aae7b118be13f65bf2e3a72881d8a06df">operator=</a> (const <a class="el" href="class_grid.html">Grid</a> &amp;sourceGrid)</td></tr>
<tr class="memdesc:aae7b118be13f65bf2e3a72881d8a06df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source with deep copying.  <a href="#aae7b118be13f65bf2e3a72881d8a06df">More...</a><br /></td></tr>
<tr class="separator:aae7b118be13f65bf2e3a72881d8a06df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f84434eb37abc5cd0979cd609b2a2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a9f84434eb37abc5cd0979cd609b2a2d8">operator=</a> (<a class="el" href="class_grid.html">Grid</a> &amp;&amp;sourceGrid)</td></tr>
<tr class="memdesc:a9f84434eb37abc5cd0979cd609b2a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with move semantics.  <a href="#a9f84434eb37abc5cd0979cd609b2a2d8">More...</a><br /></td></tr>
<tr class="separator:a9f84434eb37abc5cd0979cd609b2a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0114021b6858483965cc1bffd7b88b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aee0114021b6858483965cc1bffd7b88b">getColumns</a> () const</td></tr>
<tr class="memdesc:aee0114021b6858483965cc1bffd7b88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the number of actual columns in the grid.  <a href="#aee0114021b6858483965cc1bffd7b88b">More...</a><br /></td></tr>
<tr class="separator:aee0114021b6858483965cc1bffd7b88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9397afb775457f87b9096acf6082383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aa9397afb775457f87b9096acf6082383">getRows</a> () const</td></tr>
<tr class="memdesc:aa9397afb775457f87b9096acf6082383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the number of actual rows in the grid.  <a href="#aa9397afb775457f87b9096acf6082383">More...</a><br /></td></tr>
<tr class="separator:aa9397afb775457f87b9096acf6082383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a67056a86378f8ce24cdf3c19ee7817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a3a67056a86378f8ce24cdf3c19ee7817">setUniformPredDistribution</a> (double uppperBound, std::default_random_engine &amp;generator)</td></tr>
<tr class="memdesc:a3a67056a86378f8ce24cdf3c19ee7817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets uniform random predator distribution in each grid cell.  <a href="#a3a67056a86378f8ce24cdf3c19ee7817">More...</a><br /></td></tr>
<tr class="separator:a3a67056a86378f8ce24cdf3c19ee7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f366ddaaa75475a9597f9a85ab24d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a2f366ddaaa75475a9597f9a85ab24d59">setUniformPreyDistribution</a> (double upperBound, std::default_random_engine &amp;generator)</td></tr>
<tr class="separator:a2f366ddaaa75475a9597f9a85ab24d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c062fcf4063a811bd8d95c32bce723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a17c062fcf4063a811bd8d95c32bce723">setUniformDistribution</a> (double predUpperBound, double preyUpperbound, std::default_random_engine &amp;generator)</td></tr>
<tr class="separator:a17c062fcf4063a811bd8d95c32bce723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eeb1fef1d86fe74b45e615f0376158"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a25eeb1fef1d86fe74b45e615f0376158">predDensity</a> (bool includeWetCells=true) const</td></tr>
<tr class="memdesc:a25eeb1fef1d86fe74b45e615f0376158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates average predator density across the grid.  <a href="#a25eeb1fef1d86fe74b45e615f0376158">More...</a><br /></td></tr>
<tr class="separator:a25eeb1fef1d86fe74b45e615f0376158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc8ae18c31e8e680f6369d7c07ea881"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a7dc8ae18c31e8e680f6369d7c07ea881">preyDensity</a> (bool includeWetCells=true) const</td></tr>
<tr class="memdesc:a7dc8ae18c31e8e680f6369d7c07ea881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates average prey density across the grid.  <a href="#a7dc8ae18c31e8e680f6369d7c07ea881">More...</a><br /></td></tr>
<tr class="separator:a7dc8ae18c31e8e680f6369d7c07ea881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed06be122077b3a0c1fe7c412c2535fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cell.html">Cell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aed06be122077b3a0c1fe7c412c2535fc">operator()</a> (int i, int j)</td></tr>
<tr class="memdesc:aed06be122077b3a0c1fe7c412c2535fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload to access the <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> stored at the (i,j)th coordinates of the grid. Since the 2-D landscape is implemented as a 1-D array with the same number of elements for memory reasons, this opertor provides a way of acessing the elements of the 1-D array with two indices (i,j) as if it were a 2D-array. This operator should be used whenever direct access to the grid cells is needed and extensive use of it is made in the constructors.  <a href="#aed06be122077b3a0c1fe7c412c2535fc">More...</a><br /></td></tr>
<tr class="separator:aed06be122077b3a0c1fe7c412c2535fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f5c17cb78658f3b82a3b2d93aeb92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_cell.html">Cell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#aa89f5c17cb78658f3b82a3b2d93aeb92">operator()</a> (int i, int j) const</td></tr>
<tr class="memdesc:aa89f5c17cb78658f3b82a3b2d93aeb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second operator overload to access the <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> stored at the (i,j)th coordinate if the grid is a constant variable.  <a href="#aa89f5c17cb78658f3b82a3b2d93aeb92">More...</a><br /></td></tr>
<tr class="separator:aa89f5c17cb78658f3b82a3b2d93aeb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4c0db20b466c84a1d65004e51642e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a50f4c0db20b466c84a1d65004e51642e">dryNeighbours</a> (int i, int j) const</td></tr>
<tr class="memdesc:a50f4c0db20b466c84a1d65004e51642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of Dry neighbours of a given cell.  <a href="#a50f4c0db20b466c84a1d65004e51642e">More...</a><br /></td></tr>
<tr class="separator:a50f4c0db20b466c84a1d65004e51642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4971cb9d47440bc63488993d5647f943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a4971cb9d47440bc63488993d5647f943">printDensities</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a4971cb9d47440bc63488993d5647f943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs predator and prey densities to output stream.  <a href="#a4971cb9d47440bc63488993d5647f943">More...</a><br /></td></tr>
<tr class="separator:a4971cb9d47440bc63488993d5647f943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf89a88b063c4f641ad1331bcf9447ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#acf89a88b063c4f641ad1331bcf9447ad">printPPM</a> (std::ofstream &amp;file, int maxNumberPPM) const</td></tr>
<tr class="memdesc:acf89a88b063c4f641ad1331bcf9447ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the densities of the predators and prey to a ppm file provided.  <a href="#acf89a88b063c4f641ad1331bcf9447ad">More...</a><br /></td></tr>
<tr class="separator:acf89a88b063c4f641ad1331bcf9447ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425801f2747d6be34c10eb6535ab0829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cell.html#a21d74a2efcb79c93e5649b06a50b7cf5">Cell::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a425801f2747d6be34c10eb6535ab0829">getCellState</a> (int columnIndex, int rowIndex) const</td></tr>
<tr class="memdesc:a425801f2747d6be34c10eb6535ab0829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves state of cell at a given coordinate.  <a href="#a425801f2747d6be34c10eb6535ab0829">More...</a><br /></td></tr>
<tr class="separator:a425801f2747d6be34c10eb6535ab0829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac2cfb15a02d10acf2c124625070a2de8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#ac2cfb15a02d10acf2c124625070a2de8">TestGrid</a></td></tr>
<tr class="memdesc:ac2cfb15a02d10acf2c124625070a2de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test class for the grid.  <a href="#ac2cfb15a02d10acf2c124625070a2de8">More...</a><br /></td></tr>
<tr class="separator:ac2cfb15a02d10acf2c124625070a2de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3513576c9cced69b185e4be8fe248e8c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid.html#a3513576c9cced69b185e4be8fe248e8c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_grid.html">Grid</a> &amp;grid)</td></tr>
<tr class="memdesc:a3513576c9cced69b185e4be8fe248e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for outputting the grid.  <a href="#a3513576c9cced69b185e4be8fe248e8c">More...</a><br /></td></tr>
<tr class="separator:a3513576c9cced69b185e4be8fe248e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Models a 2D landscape of cells. </p>
<p>A <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> consists of a (2D) array of cells that can either be land or water and each have a predator and prey density. The actual array is implemented with a "halo" of Wet cells, this means that the densities of predators and prey in these cells is zero. This is very useful for implementing any differential equations where we may inadvertently check the #columns + 1 or #rows + 1, so rather than introducing bounds checking, we can introduce this boundary. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4ac9ff4f63552b4c61ff90fcb35ad66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac9ff4f63552b4c61ff90fcb35ad66c">&#9670;&nbsp;</a></span>Grid() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates a grid of size 0 with a nullptr as its grid </p>

</div>
</div>
<a id="ab64f5607521a89e7a2fb99cbfa5f2b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64f5607521a89e7a2fb99cbfa5f2b44">&#9670;&nbsp;</a></span>Grid() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from some input array representing the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a>. </p>
<p>This constructor will dynamically allocate a 1-D array of Cells with a halo of water cells, which represents the 2-D landscape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>Integer value representing the number of columns in the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> object, not including the halo.</td></tr>
    <tr><td class="paramname">rows</td><td>Integer value representing the number of rows in the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> object, not including the halo.</td></tr>
    <tr><td class="paramname">data</td><td>Integer array of values which represent the Wet and Dry cells in the grid, must be 1 and 0 only and must have the same number of rows and columns as the explicit values provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be5432331273bc420c252ea09631965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5432331273bc420c252ea09631965">&#9670;&nbsp;</a></span>Grid() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with deep copying. </p>
<p>Due to the dynamic memory allocation that takes place in the constructor, the copy constructor is overloaded to insure that deep copying takes place and that there are no dangling pointers when grid objects go out of scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceGrid</td><td>constant <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference from which the deep copying will be done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3828d0bf34f6c97ed93adc84d4ce6c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3828d0bf34f6c97ed93adc84d4ce6c4b">&#9670;&nbsp;</a></span>Grid() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grid.html">Grid</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with move semantics. </p>
<p>This is implemented for performance reasons. If a grid is ever returned from a function, for example, a function that might update the grid, it is quicker to do this via move semantics rather than copy construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceGrid</td><td>constant R-value reference from which the ownership of the member variables will be transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3661d0a7f998caaaf8627d7a67072116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3661d0a7f998caaaf8627d7a67072116">&#9670;&nbsp;</a></span>~Grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::~Grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases memory held by m_cellArray. </p>
<p>Destructor is explicitly implemented since the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> class has dynamic memory allocation in its constructors of the m_cellArray member variable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50f4c0db20b466c84a1d65004e51642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4c0db20b466c84a1d65004e51642e">&#9670;&nbsp;</a></span>dryNeighbours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::dryNeighbours </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of Dry neighbours of a given cell. </p>
<p>Neighbours are only considered to be non-diagonal, so this function counts the number of Dry cells directly above/below and to the left/right of the specified cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>column number/x-coordinate of cell.</td></tr>
    <tr><td class="paramname">j</td><td>row number/y-coordinate of cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value representing number of Dry neighbours of the cell. </dd></dl>

</div>
</div>
<a id="a425801f2747d6be34c10eb6535ab0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425801f2747d6be34c10eb6535ab0829">&#9670;&nbsp;</a></span>getCellState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cell.html#a21d74a2efcb79c93e5649b06a50b7cf5">Cell::State</a> Grid::getCellState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves state of cell at a given coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>integer value representing the column in which the state of the cell should be retrieved.</td></tr>
    <tr><td class="paramname">rowIndex</td><td>integer value representing the row in which the state of the cell should be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_cell.html#a21d74a2efcb79c93e5649b06a50b7cf5" title="Enum that represents a value that can be either wet or dry. ">Cell::State</a> value (either wet or dry) representing the state of the specified cell. </dd></dl>

</div>
</div>
<a id="aee0114021b6858483965cc1bffd7b88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0114021b6858483965cc1bffd7b88b">&#9670;&nbsp;</a></span>getColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::getColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the number of actual columns in the grid. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of m_columns, the actual number of columns in the grid without a halo of water. </dd></dl>

</div>
</div>
<a id="aa9397afb775457f87b9096acf6082383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9397afb775457f87b9096acf6082383">&#9670;&nbsp;</a></span>getRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::getRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the number of actual rows in the grid. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of m_rows, the actual number of rows in the grid without a halo of water. </dd></dl>

</div>
</div>
<a id="aed06be122077b3a0c1fe7c412c2535fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed06be122077b3a0c1fe7c412c2535fc">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cell.html">Cell</a> &amp; Grid::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator overload to access the <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> stored at the (i,j)th coordinates of the grid. Since the 2-D landscape is implemented as a 1-D array with the same number of elements for memory reasons, this opertor provides a way of acessing the elements of the 1-D array with two indices (i,j) as if it were a 2D-array. This operator should be used whenever direct access to the grid cells is needed and extensive use of it is made in the constructors. </p>
<p>The indexing system for this operator and therefore the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> itself follows that given in the specification document for this project in the figure in section 2.1. i.e. (i,j) corresponds to x (column number) and y coordinates (row number) where the origin is taken to be in the bottom left corner. This is not the same as matrix notation. For example (3,4) would return the cell in the 3rd column of the 4th row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>column number/x-coordinate of cell.</td></tr>
    <tr><td class="paramname">j</td><td>row/y-coordinate of cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> reference to the cell at the (i,j) coordinate. </dd></dl>

</div>
</div>
<a id="aa89f5c17cb78658f3b82a3b2d93aeb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89f5c17cb78658f3b82a3b2d93aeb92">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_cell.html">Cell</a> &amp; Grid::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Second operator overload to access the <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> stored at the (i,j)th coordinate if the grid is a constant variable. </p>
<p>This function behaves in exactly the same way as its non-constant counterpart. However the non-constant operator() overload will not work with any constant grid objects, since it returns a reference, it would be able to edit contents of the constant Cells m_cellArray member. For an explanation of the indexing system please see the non-constant overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>column number/x-coordinate of cell.</td></tr>
    <tr><td class="paramname">j</td><td>row/y-coordinate of cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a> reference to the cell at the (i,j) coordinate, so that the main method cannot edit the contents of a constant <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a>. </dd></dl>

</div>
</div>
<a id="aae7b118be13f65bf2e3a72881d8a06df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7b118be13f65bf2e3a72881d8a06df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grid.html">Grid</a> &amp; Grid::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source with deep copying. </p>
<p>Due to the dynamic memory allocation that takes place in the constructor, the copy assignment operator is overloaded to insure that deep copying takes place in any assignment and that there are no dangling pointers when grid objects go out of scope. It also checks for self assignment which could otherwise lead to memory problems. This pairs with the copy constructor that also does deep copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceGrid</td><td>constant <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference from which the deep copying will be done in the assignment of the grid member variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference *this, so that the newly assigned operator may be chained into other assignment operations. </dd></dl>

</div>
</div>
<a id="a9f84434eb37abc5cd0979cd609b2a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f84434eb37abc5cd0979cd609b2a2d8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grid.html">Grid</a> &amp; Grid::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grid.html">Grid</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> objects from a source <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> with move semantics. </p>
<p>This is implemented for performance reasons to go with the move constructor. If an R-value <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> is assigned to a <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> variable, this operator will be used instead of the normal copy assignment and will be more performant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceGrid</td><td>constant R-value <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference from which the ownership of the member variables will be transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference *this, so that the newly assigned operator may be chained into other assignment operations. </dd></dl>

</div>
</div>
<a id="a25eeb1fef1d86fe74b45e615f0376158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eeb1fef1d86fe74b45e615f0376158">&#9670;&nbsp;</a></span>predDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Grid::predDensity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeWetCells</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates average predator density across the grid. </p>
<p>Calculates the average value of the predator density across the entire grid, not included the halo of Wet cells. However, the average can be taken over just the Dry cells in the grid, or over the Dry and Wet cells in the grid if the corresponding argument is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeWetCells</td><td>bool value that represents whether the user wants to include the Wet cells in the grid as the well as the Dry cells, as the total number of cells to take the average over. This value defaults to true i.e. the default behaviour is to average over all cells in the grid including the Wet ones where predator/prey densities will be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value representing the average predator density across the grid either including or not including the Wet cells, depending on how the function was called. </dd></dl>

</div>
</div>
<a id="a7dc8ae18c31e8e680f6369d7c07ea881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc8ae18c31e8e680f6369d7c07ea881">&#9670;&nbsp;</a></span>preyDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Grid::preyDensity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeWetCells</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates average prey density across the grid. </p>
<p>Calculates the average value of the prey density across the entire grid, not included the halo of Wet cells. However, the average can be taken over just the Dry cells in the grid, or over the Dry and Wet cells in the grid if the corresponding argument is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeWetCells</td><td>bool value that represents whether the user wants to include the Wet cells in the grid as the well as the Dry cells, as the total number of cells to take the average over. This value defaults to true i.e. the default behaviour is to average over all cells in the grid including the Wet ones where predator/prey densities will be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value representing the average prey density across the grid either including or not including the Wet cells, depending on how the function was called. </dd></dl>
<p>Total up the number of Wet cells as well. </p>

</div>
</div>
<a id="a4971cb9d47440bc63488993d5647f943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4971cb9d47440bc63488993d5647f943">&#9670;&nbsp;</a></span>printDensities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::printDensities </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs predator and prey densities to output stream. </p>
<p>Outputs densities of predator and prey for each cell in the format: i j predator density prey density and repeats this for all cells in the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>std::ostream reference which is the output stream. This will also work for fstream since it inherits from ostream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf89a88b063c4f641ad1331bcf9447ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf89a88b063c4f641ad1331bcf9447ad">&#9670;&nbsp;</a></span>printPPM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Grid::printPPM </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumberPPM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the densities of the predators and prey to a ppm file provided. </p>
<p>This function will print the to the file in the format:</p>
<p>P3 (required for a PPM and means this is a RGB colour image in ASCII) m_columns m_rows (width and height of image) MAX (maximum value for each colour) 0 predDensity preyDensity (at coordinate (m_rows, 1)) 0 predDensity preyDensity (at coordinate (m_rows, 2)) 0 predDensity preyDensity (at coordinate (m_rows, 3)) . . . . . . . . . . . . . . . . . . . . . . . . 0 predDensity preyDensity (at coordinate (1, m_columns))</p>
<p>To overcome the fact that each line can contain at most 70 characters each coordinate pixel is printed to a new line, this works fine formatting wise since the number of rows and columns are printed explicitly at the top of the file, so for any display purposes the file knows how to "count" the values into the correct coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>ppm file to which the densities should be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c062fcf4063a811bd8d95c32bce723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c062fcf4063a811bd8d95c32bce723">&#9670;&nbsp;</a></span>setUniformDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::setUniformDistribution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>predUpperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>preyUpperbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets uniform random predator and prey distribution in each grid cell.</p>
<p>This function works by just calling the <a class="el" href="class_grid.html#a3a67056a86378f8ce24cdf3c19ee7817" title="Sets uniform random predator distribution in each grid cell. ">setUniformPredDistribution()</a> and setUniormPreyDistribution() functions with their respective upper bounds. For a more in depth discussion of the functionality please see those functions where the implementation is explained in full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predUpperBound</td><td>floating point value that provides the upper bound for the random number distribution of the predators.</td></tr>
    <tr><td class="paramname">preyUpperBound</td><td>floating point value that provides the upper bound for the random number distribution of the prey.</td></tr>
    <tr><td class="paramname">generator</td><td>a default_random_engine reference from the std library &lt;random&gt; class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a67056a86378f8ce24cdf3c19ee7817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a67056a86378f8ce24cdf3c19ee7817">&#9670;&nbsp;</a></span>setUniformPredDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::setUniformPredDistribution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uppperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets uniform random predator distribution in each grid cell. </p>
<p>Initially predator density will be zero in each cell since the constructors do no initialization of densities. This function sets the density of predators in every Dry grid cell to a random number between 0 and upperBound according to a uniform distribution. i.e. If upperBound = 5.0, then each dry cell will be assigned a density between 0.0 and 5.0 according to a uniform distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperBound</td><td>floating point value that provides the upper bound for the random number distribution.</td></tr>
    <tr><td class="paramname">generator</td><td>a default_random_engine reference from the std library &lt;random&gt; class. This is used to generate the random number from the distribution which is a local variable within the function. The generator should be provided by the main method so that chains of random predator densities can be reproduced if required for debugging. The generator is passed as a reference so that if any other functions which makes use of the same distribution are called from the main method, they do not produce the same chain of random numbers, rather they act on the next random number given by the generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f366ddaaa75475a9597f9a85ab24d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f366ddaaa75475a9597f9a85ab24d59">&#9670;&nbsp;</a></span>setUniformPreyDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::setUniformPreyDistribution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets uniform random prey distribution in each grid cell.</p>
<p>Intially prey density will be zero in each cell since the constructors do no initialization of densities. This function sets the density of predators in every Dry grid cell to a random number between 0 and upperBound according to a uniform distribution. i.e. If upperBound = 5.0, then each dry cell will be assigned a density between 0.0 and 5.0 according to a uniform distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperBound</td><td>floating point value that provides the upper bound for the random number distribution.</td></tr>
    <tr><td class="paramname">generator</td><td>a default_random_engine reference from the std library &lt;random&gt; class. This is used to generate the random number from the distribution which is a local variable within the function. The generator should be provided by the main method so that chains of random prey densities can be reproduced if required for debugging. The generator is passed as a reference so that if any other functions which makes use of the same distribution are called from the main method, they do not produce the same chain of random numbers, rather they act on the next random number given by the generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3513576c9cced69b185e4be8fe248e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3513576c9cced69b185e4be8fe248e8c">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator overload for outputting the grid. </p>
<p>Outputs the <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> into an output stream in the format: #columns #rows x x ..... x x x ..... x . . ..... . . . ..... . . . ..... . x x ..... x where x takes on the values of 0 or 1 depending on whether the corresponding (i,j)th cell from the bottom left corner is Wet or Dry respectively.</p>
<p>This is a friend function since the first operand (argument on left of operator) is not the <a class="el" href="class_cell.html" title="Models a single cell. ">Cell</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>std::ostream reference which is the output.</td></tr>
    <tr><td class="paramname">grid</td><td>const <a class="el" href="class_grid.html" title="Models a 2D landscape of cells. ">Grid</a> reference which is the grid to be sent into the output stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream reference that is the same as the out parameter, this is so one can put this operator in a chain of output operators. </dd></dl>

</div>
</div>
<a id="ac2cfb15a02d10acf2c124625070a2de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cfb15a02d10acf2c124625070a2de8">&#9670;&nbsp;</a></span>TestGrid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_test_grid.html">TestGrid</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test class for the grid. </p>
<p>Declare a <a class="el" href="class_test_grid.html" title="Tests the Grid class. ">TestGrid</a> friend member variable to allow access to private member variables in test class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_grid_8hpp_source.html">Grid.hpp</a></li>
<li>src/Grid.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
